"""
#* 추상화 : abstraction
#* 불필요한 정보는 숨기고 중요한(필요한) 정보만을 표현함으로써
#* 공통의 속성 값이나 행위(method)를 하나로 묶어 이름을 붙이는 것이다.


Q
실무에서는 사용 예는 어떻게 될까요?

A
먼저, 추상화의 사전적 정의는 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작업입니다.

즉, 추상화는 공통된 것들을 하나로 묶어 일반화하는 사고 과정입니다.

추상화 작업을 통해 얻는 이점은 공통된 현실 문제에 있어서 일반적인 솔루션을 만듦으로써 새로운 현실 문제가 발생했을 때 쉽게 해결할 수 있습니다.

저희 예제에서 사람들에게 편의를 제공하는 음성 인공지능 서비스인 시리, 자비스, 빅스비가 있었습니다.

이 음성 로봇들은 공통된 기능이 있어서 Robot이라는 class를 통해 일반화(추상화) 작업을 하고 만들어진 Robot class(설계도) 통해 새롭게 음성 로봇인 시리, 자비스, 빅스비 로봇을 만들었었죠.

만약 추가적으로 새롭게 시리, 자비스, 빅스비와 공통된 기능을 수행하는 프로그램인 "드로이드"를 제작한다고 합시다.

이 경우 만들어진 Robot class를 통해 인스턴스로 찍어내기만 하면 빠르고 쉽게 새로운 드로이드 프로그램을 만들 수 있습니다.

만약 추상화(일반화) 사고 과정을 통해 Robot이라는 class를 만들지 않았다면 다시 처음부터 "안녕이라고 했을 때 이를 컴퓨터가 알아들을 수 있도록 컴퓨터 언어로 바꾸고 인공지능 기술을 사용하여 이에 반응하는 기능인 say_hi", "덧셈 기능을 수행하는 cal_add" 등 기능을 다시 만들어야 합니다.

이는 메모리 낭비, 인건 낭비, 유지보수의 어려움 등의 문제로 이어지게 되겠죠.

이제 다른 관점에서 생각해본다면, 시리, 자비스, 빅스비 로봇을 만든 회사에서 Robot class 안에 존재하는 "say_hi", "add_cal" 기능을 다른 회사에 판다고 생각한다면 Robot class 가 적힌 스크립트 파일을 그대로 판매하면 됩니다.

만일 추상화(일반화) 과정으로 Robot class를 만들지 않았다면 해당하는 기능을 다시 따로 만들어 판매해야 합니다. 다시 따로 만들다가 기다리던 회사는 다른 회사와 계약해 버리면 슬픈 상황이겠죠.

실무에서는 동일한 결로 적용됩니다.

1. 웹 엔지니어 같은 경우
예를들어 블로그 서비스를 개발한다고 합시다. 블로그 서비스에서 포스트를 작성하고 편집하고 독자들이 읽을 수 있는 프로그램을 만들고 이제 댓글을 작성하고 편집하고 댓글러들이 읽을 수 있는 프로그램도 만들어야 합니다.

벌써 공통된 기능들이 보입니다.

텍스트를 작성하고(create), 텍스트를 수정하고(update), 텍스트를 읽는(read) 반복된 기능들을 추상화(일반화)하여 FormEditor class(설계도)를 만들고 해당 기능들을 사용하는 프로그램에서 인스턴스를 찍어서 만들면 하나하나 만드는 것보다 훨씬 더 쉽고 빠르게, 가독성도 좋은 코딩을 할 수 있게 되겠죠.

실제로 이런 클래스들을 미리 제공해주는 코드 뭉치도 있습니다. 예로 django라는 웹 프레임워크가 있는데요. 인스타그램 서비스 또한 이 django로 개발되었습니다. 해당하는 코드 링크는 https://github.com/django/django/blob/main/django/views/generic/edit.py 입니다. 참고하면 좋을 것 같아요!

2. 인공지능 알고리즘을 개발하는 엔지니어인 경우
예를들어 딥러닝 알고리즘을 개발하는 엔지니어가 VGG16 모델(프로그램)과 ResNet 모델(프로그램)의 성능을 비교하는 프로그램을 짠다고 합시다.

동일한 데이터 셋과 환경에서 VGG 모델과 ResNet 모델의 성능 차이를 비교한다고 했을 때 각각 모델(프로그램)에 대하여 "데이터 셋 로드", "데이터 전처리", "손실함수 적용" 등 동일한 환경에서 동일한 기능이 수행됩니다. 이 경우에 동일한 기능을 하는 Machine이라는 class를 만들고 이 class를 상속을 받아 각 모델에 해당하는 특별한 기능(비교 대조할 기능)을 다시 재정의하게 되면 처음부터 하나하나 동일한 코드를 작성해서 코딩하는 것이 아니라 재사용되는 공통된 로직 위에서 특별히 비교할 기능을 구현해서 사용하면 가독성도 좋고 안전하게 실험이 가능합니다. 해당하는 코드 링크입니다. https://github.com/amamov/vgg16-vs-resnet/blob/main/VGG16.py, https://github.com/amamov/vgg16-vs-resnet/blob/main/ResNet.py *상속은 후에 강의에서 다룹니다.

객체지향 프로그래밍에서의 추상화 사고는 저희 예제처럼 공통된 기능이나 속성 값에 있어서 일반적인 class 설계도를 만들면서 재사용성과 유지보수성을 높이는 방법에서 사용되기도 하고 이러한 클래스들이 여러 개가 있을 때 클래스들을 추상화하여 새로운 하나의 추상 클래스를 설계할 때 사용되기도 합니다. 추상 클래스 같은 경우는 보너스 강의로 제작 계획에 있습니다. 참고해주세요 :)

제가 로봇이라는 예제로 설명한 이유는 객체지향 기본 사고과정을 포괄하는 예제라고 판단되었기 때문입니다. 그렇기 때문에 조금은 추상적인 예제일 수 있습니다. 추상적으로 여겨지시는 부분이나 이해가 잘 되지 않는 부분은 언제든 질문해주세요.🙃

추가적으로 궁금하신 내용이나 이해가 되지 않는 부분 또한 질문 부탁드립니다.

감사합니다. :)
"""


class Robot:
    population = 0

    # 생성자 함수
    def __init__(self, name, code):
        self.name = name  # 인스턴스 변수
        self.code = code  # 인스턴스 변수
        Robot.population += 1

    # 인스턴스 메서드
    def say_hi(self):
        # code
        print(f'Grettings. my masters call me {self.name}')

    # 인스턴스 메서드
    def cal_add(self, a, b):
        return a + b

    # 인스턴스 메서드
    def die(self):
        print(f'{self.name} is being destroyed!')
        Robot.population -= 1
        if Robot.population == 0:
            print(f'{self.name} was the last one.')
        else:
            print(f'There are still {Robot.population} robots working.')

    # 클래스 메서드
    @classmethod
    def how_many(cls):
        print(f'We have {cls.population}!')


# instance
siri = Robot(name='siri', code=12423232)

# instance
jarvis = Robot(name='jarvis', code=32342323)

# instance
bixby = Robot(name='bixby', code=54434322)

siri.how_many()
siri.die()

